### 原理

**比较两个DOM树的差异是Virtual DOM算法的核心部分**，这就是所谓的Virtual DOM的diff 算法。两个树的完全diff算法是一个时间复杂度为O(n^3)的问题，但是在前端中，很少会跨级移动dom元素。所以Virtual DOM只会对同一层级的元素进行对比。这样算法复杂度为**O(n)**;  
所以在Vue中，默认是同级元素进行对比，**这点和Git的算法不同**。

![同级元素比较](https://www.flygoing.cn/images/2019-7-14/DOM_diff同级元素比较示意图.png)

a. 实际代码中，会对新旧两棵树进行深度优先遍历，这样每个节点都会有一个唯一标记，

b. 在深度优先遍历时，没遍历到一个节点就会把该节点和新的树进行对比。如果有==差异==，就会记录到一个对象里去，p是patches[1],ul是patches[3],类推

![同级元素比较](https://www.flygoing.cn/images/2019-7-14/DOM_diff深度优先遍历.png)

c. 节点差异指的是什么？对于DOM操作来说可能会：
1. 替换原来的节点，例如把div换成a
2. 移动、删除、新增子节点 如上图：p和ul互换顺序
3. 修改节点属性
4. 对于文本节点，文本内容可能会改变 如修改文本2的内容为Virtual DOM。

d. 如果把全部顺序都换了，那么就要全部删除再添加(列表对比算法)：
1. a b c d e f g h i
2. c d e f g i a h i

> 要注意的是，在DOM diff算法里，没有移动元素的概念，它只会进行比较，如果新的和旧的不同，它也会删除掉旧的，更新新的，(哪怕实际上旧的该位置的元素只是向后(或向前)移动了位置。

e. 这个问题抽象出来其实是字符串的最小编辑举例问题(Edition Distance)，最常见的解决算法是：Levenshtein Distance。通过动态规划求解。时间复杂度为O(M*N)。

f. 但是在实际操作中，不需要真的达到最小的操作，只需要优化一些常见的移动状况，牺牲一定得DOM操作，让算法时间复杂度达到线性O(max(M,N))。

> 要注意，因为tagName是可重复的，所以要给子节点添加唯一标识key

g. 通过深度优先遍历两棵树，每层节点进行对比，记录下每个节点的差异

h. JavaScript对象数和render出来真正的DOM树的信息、结构是一样的。所以我们可以对两颗树都进行深度优先遍历，遍历的时候从步骤b，生成的patches对象中找出当前遍历的节点差异，然后进行DOM操作。

所以对于Vue的dom diff算法的了解，我们在使用Vue时应：
1. 尽量不要跨层级的修改dom，因为它会将原有涉及的dom元素全部删除，再重新创建(很麻烦)
2. 设置key，可以最大化的利用节点
3. 不要盲目相信diff的效率，必要时可以手工优化

Virtual DOM算法主要是实现上面步骤的三个函数：element、diff、patch。

![DOM diff主要步骤](https://www.flygoing.cn/images/2019-7-14/DOM_diff主要步骤.png)

Vue的dom diff的步骤简单来说是两步：
1. 深度优先遍历，进行同级比较
2. 节点存在差异，则打一个补丁
3. 然后循环补丁集合，将新的属性或值替换旧的，就可以得到新树

DOM diff 补丁的规则：
参见以上步骤7 节点差异