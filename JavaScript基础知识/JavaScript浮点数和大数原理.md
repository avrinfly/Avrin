先抛几个问题

1. **为什么0.1+0.2 != 0.3?**
2. **为什么1.005.toFixed(2) = 1.00 而不是1.01**
3. **为什么会有Number.MAX_VALUE和Number.MAX_SAFE_INTEGER**

想知道以上问题的原因，首先要知道几个概念
### 双精度存储
首先我们应该了解JavaScript的number类型在计算机中是如何存储的，这也是一切问题的基础。

JavaScript的数字都是number类型，不管是整数还是浮点数都以[IEEE754双精度](https://zh.wikipedia.org/wiki/IEEE_754#64%E4%BD%8D%E9%9B%99%E7%B2%BE%E5%BA%A6)的格式存储在计算机中。

什么是双精度呢？就是**以64个bit位来存储**，具体的存储格式是：
![v2-6663575d6d2bf2eeeb1ec0cf9cdee7f9_b](46AED022832C40ECA342CD4C028B5AC5)
![v2-e953e717cb57d67759f817a3e3131beb_b](619028B5D71D46448A450E6ECC3874E9)
分别是**1个符号位+11个指数位+52个尾数位**

举个例子：如果是数字5.5的话，则计算过程是这样的：
> 5.5转二进制====> 101.1科学计数法 ====> 1.011*2^2  
> 存入计算机:  
> 符号位：0  
> 指数位: 2+1023 ====> 1025转二进制 ====> 10000000001  
> 尾数位: 1.011 隐去小数点左边的1 ====> 011

计算机，如下图，截图来自[IEEE754可视化](http://bartaz.github.io/ieee754-visualization/)
![v2-e953e717cb57d67759f817a3e3131beb_b](D80C7562CC97481BBBAAC37E1E1E6CD8)

了解完基础后，就可以看开头的三个问题了
#### 为什么0.1+0.2 != 0.3?
结果可以在浏览器测试
![image](3FE4BF3A31204FA7915A16189FF108A4)

根据之前的基础，来理一理：
> 0.1转二进制 ====> 0.0001100110011001100...(1100循环) ====>转科学计数法 ====> 1.100110011...(1100循环) *2^-4  
> 数据时无限循环的，但可供使用的尾数却是有限的，只有52位可以使用，从第53位开始会被舍去并且进位

最终在计算机中的存储如下图：
![v2-7acd617725caebe09de91b75a4d424c3_b](F12D2221C26D413983FBB1E052FCB809)
类似的0.2在计算机中的存储如下：
![v2-e0dfa7aa548ad0a0bd533fcb47c2f538_b](22D357B9BBAA42C8B293404F3F218CC7)
所以最终计算结果是：
> 0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111

计算结果转换为十进制数字就是：0.30000000000000004

所以第一个问题的原因为：0.1和0.2在计算机中的二进制存储会让它们本身损失掉一定的精度，而它们在计算机中的二进制存储转换成十进制时已经不是真正的0.1和0.2了，相加的结果也就自然不是0.3了。

**问题来了，既然0.1在计算机中的存储已经有了舍入误差，那为什么num=0.1能得到0.1呢？**

可以在控制台使用[toPrecision](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision)看一下0.1在不同精度下的返回
![v2-98b53872fd97810cb7a66dea45e3962b_b](B911AB5D91D14D20AD41A00F948B264A)
可以看出其实0.1是截断了一部分精度后得到的。那该问题就等于：双精度浮点数是按什么规则来截断的？

在双精度浮点数的英文wiki中，有这么一段话可以来解释：
![v2-b31d1bab56b114c0dff0fa33a267a90e_b](5DF1D122EC75453FA7A10562059E004A)
大意是：**如果一个IEEE 754的双精度浮点数被转成至少含17位有效数字的十进制数字字符串，当这个字符串转回双精度浮点数时，必须要跟原来的数相同；换句话说，如果一个双精度浮点数转为十进制的数字时，只要它转回来的双精度浮点数不变，精度取最短的那个就行。**

以0.1举例：0.1和0.10000000000000001转成双精度浮点数的存储是一样的，所以取最短的0.1就行了。

第二个问题：
#### 为什么1.005.toFixed(2)=1.00而不是1.01
因为在第一个问题中已经说了，一个十进制数字转为双精度浮点数然后再取出来时，跟原十进制数字可能会有误差，试一下1.005取20个精度：

![image](967A46BD37E047D19E345BBC48CA80D1)

很明显1.005只是一个被截断后的数字，它的双精度浮点数代表的20位精度的数字是1.0049999999999998934，所以进行保留2位的四舍五入时，两位后面的数字会被全部舍去。

#### 为什么会有Number.MAX_VALUE和Number.MAX_SAFE_INTEGER这两个常量同时存在？

在控制台打印结果：
![image](005E4FB86D864F6C8F32FD2CE125A459)
为什么最大安全整数是2^53-1?前面说到了JavaScript浮点数存储是52尾数位，但因为科学计数法小数点左侧的1会在存储时省去，所以52位尾数+省去的1位 = 53个可表示的位数。

二进制的53位全是1时转换为十进制为：2^53-1=9007199254740991

**哪为什么2^53-1是最大安全整数呢？比它大会怎样?**
![image](089E3B7FC5534DD7A1A07FF2BF6D71C6)

以2^53来说明为什么2^53-1是最大安全整数，安全在哪里
> 2^53 转二进制 ====> 100000000000000000000000000000000000000000000000000000(53个0)  
转为科学计数法 ====> 1.00000000000000000000000000000000000000000000000000000(53个0)*2^53   
存入计算机 ====> 尾数位只有52个，所以截掉末尾的0只能存52个0

> 2^53+1 转二进制 =====>100000000000000000000000000000000000000000000000000001(52个0)  
转为科学计数法 =====> 1.00000000000000000000000000000000000000000000000000001(52个0)  
存入计算机 =====> 尾数位只有52位所以截掉末尾的1只能存52个0

可以看出来，2^53和2^53+1在计算机中的存储尾数和指数都相同，所以如果两个不同的数在计算机中的存储是一样的，这样就非常不安全。

所以2^53-1是JavaScript里边的最大安全整数。至于Number.MAX_VALUE,就是把尾数位和指数位都设为1再转成十进制就好了。

#### 如何解决呢
以上说到的浮点数运算、舍入运算、大数运算，都可以使用[bignumber](https://github.com/MikeMcl/bignumber.js)这个库来解决，打开链接就可以在控制台写demo

#### 后记
业务中很多难缠的bug往往是基础知识了解的不够深入造成的，了解这些原理可以清晰的知道自己在写什么，并且快速的debug，不至于陷入cv（control+C、control+V）工程师的循环中。